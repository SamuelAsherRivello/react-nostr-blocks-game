function pe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function ve(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function on(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");pe(t.outputLen),pe(t.blockLen)}function vt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function sn(t,e){ve(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const qt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Le=t=>t instanceof Uint8Array,Rt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),W=(t,e)=>t<<32-e|t>>>e,cn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!cn)throw new Error("Non little-endian hardware is not supported");function fn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function ee(t){if(typeof t=="string"&&(t=fn(t)),!Le(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function an(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Le(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}let $e=class{clone(){return this._cloneInto()}};function un(t){const e=r=>t().update(ee(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function He(t=32){if(qt&&typeof qt.getRandomValues=="function")return qt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function ln(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),f=Number(n>>o&i),c=Number(n&i),s=r?4:0,a=r?0:4;t.setUint32(e+s,f,r),t.setUint32(e+a,c,r)}let hn=class extends $e{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Rt(this.buffer)}update(e){vt(this);const{view:n,buffer:r,blockLen:o}=this;e=ee(e);const i=e.length;for(let f=0;f<i;){const c=Math.min(o-this.pos,i-f);if(c===o){const s=Rt(e);for(;o<=i-f;f+=o)this.process(s,f);continue}r.set(e.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){vt(this),sn(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;ln(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=Rt(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=s/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)c.setUint32(4*u,h[u],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:f,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=f,o%n&&e.buffer.set(r),e}};const dn=(t,e,n)=>t&e^~t&n,gn=(t,e,n)=>t&e^t&n^e&n,wn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ot=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),st=new Uint32Array(64);let pn=class extends hn{constructor(){super(64,32,8,!1),this.A=ot[0]|0,this.B=ot[1]|0,this.C=ot[2]|0,this.D=ot[3]|0,this.E=ot[4]|0,this.F=ot[5]|0,this.G=ot[6]|0,this.H=ot[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:f,G:c,H:s}=this;return[e,n,r,o,i,f,c,s]}set(e,n,r,o,i,f,c,s){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=f|0,this.G=c|0,this.H=s|0}process(e,n){for(let u=0;u<16;u++,n+=4)st[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const x=st[u-15],b=st[u-2],p=W(x,7)^W(x,18)^x>>>3,l=W(b,17)^W(b,19)^b>>>10;st[u]=l+st[u-7]+p+st[u-16]|0}let{A:r,B:o,C:i,D:f,E:c,F:s,G:a,H:h}=this;for(let u=0;u<64;u++){const x=W(c,6)^W(c,11)^W(c,25),b=h+x+dn(c,s,a)+wn[u]+st[u]|0,l=(W(r,2)^W(r,13)^W(r,22))+gn(r,o,i)|0;h=a,a=s,s=c,c=f+b|0,f=i,i=o,o=r,r=b+l|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,f=f+this.D|0,c=c+this.E|0,s=s+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(r,o,i,f,c,s,a,h)}roundClean(){st.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Gt=un(()=>new pn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Te=BigInt(0),Tt=BigInt(1),yn=BigInt(2),Nt=t=>t instanceof Uint8Array,bn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Et(t){if(!Nt(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=bn[t[n]];return e}function Ne(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function ne(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function mt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=r*2,i=t.slice(o,o+2),f=Number.parseInt(i,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");n[r]=f}return n}function M(t){return ne(Et(t))}function re(t){if(!Nt(t))throw new Error("Uint8Array expected");return ne(Et(Uint8Array.from(t).reverse()))}function ut(t,e){return mt(t.toString(16).padStart(e*2,"0"))}function oe(t,e){return ut(t,e).reverse()}function xn(t){return mt(Ne(t))}function Z(t,e,n){let r;if(typeof e=="string")try{r=mt(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(Nt(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function gt(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Nt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function En(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function mn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Bn(t){let e;for(e=0;t>Te;t>>=Tt,e+=1);return e}function An(t,e){return t>>BigInt(e)&Tt}const In=(t,e,n)=>t|(n?Tt:Te)<<BigInt(e),se=t=>(yn<<BigInt(t-1))-Tt,kt=t=>new Uint8Array(t),ye=t=>Uint8Array.from(t);function _e(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=kt(t),o=kt(t),i=0;const f=()=>{r.fill(1),o.fill(0),i=0},c=(...u)=>n(o,r,...u),s=(u=kt())=>{o=c(ye([0]),u),r=c(),u.length!==0&&(o=c(ye([1]),u),r=c())},a=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const x=[];for(;u<e;){r=c();const b=r.slice();x.push(b),u+=r.length}return gt(...x)};return(u,x)=>{f(),s(u);let b;for(;!(b=x(a()));)s();return f(),b}}const Sn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function St(t,e,n={}){const r=(o,i,f)=>{const c=Sn[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const s=t[o];if(!(f&&s===void 0)&&!c(s,t))throw new Error(`Invalid param ${String(o)}=${s} (${typeof s}), expected ${i}`)};for(const[o,i]of Object.entries(e))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return t}const Un=Object.freeze(Object.defineProperty({__proto__:null,bitGet:An,bitLen:Bn,bitMask:se,bitSet:In,bytesToHex:Et,bytesToNumberBE:M,bytesToNumberLE:re,concatBytes:gt,createHmacDrbg:_e,ensureBytes:Z,equalBytes:En,hexToBytes:mt,hexToNumber:ne,numberToBytesBE:ut,numberToBytesLE:oe,numberToHexUnpadded:Ne,numberToVarBytesBE:xn,utf8ToBytes:mn,validateObject:St},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),j=BigInt(1),ht=BigInt(2),vn=BigInt(3),Yt=BigInt(4),be=BigInt(5),xe=BigInt(8);BigInt(9);BigInt(16);function P(t,e){const n=t%e;return n>=K?n:e+n}function Ln(t,e,n){if(n<=K||e<K)throw new Error("Expected power/modulo > 0");if(n===j)return K;let r=j;for(;e>K;)e&j&&(r=r*t%n),t=t*t%n,e>>=j;return r}function G(t,e,n){let r=t;for(;e-- >K;)r*=r,r%=n;return r}function Dt(t,e){if(t===K||e<=K)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=P(t,e),r=e,o=K,i=j;for(;n!==K;){const c=r/n,s=r%n,a=o-i*c;r=n,n=s,o=i,i=a}if(r!==j)throw new Error("invert: does not exist");return P(o,e)}function $n(t){const e=(t-j)/ht;let n,r,o;for(n=t-j,r=0;n%ht===K;n/=ht,r++);for(o=ht;o<t&&Ln(o,e,t)!==t-j;o++);if(r===1){const f=(t+j)/Yt;return function(s,a){const h=s.pow(a,f);if(!s.eql(s.sqr(h),a))throw new Error("Cannot find square root");return h}}const i=(n+j)/ht;return function(c,s){if(c.pow(s,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,h=c.pow(c.mul(c.ONE,o),n),u=c.pow(s,i),x=c.pow(s,n);for(;!c.eql(x,c.ONE);){if(c.eql(x,c.ZERO))return c.ZERO;let b=1;for(let l=c.sqr(x);b<a&&!c.eql(l,c.ONE);b++)l=c.sqr(l);const p=c.pow(h,j<<BigInt(a-b-1));h=c.sqr(p),u=c.mul(u,p),x=c.mul(x,h),a=b}return u}}function Hn(t){if(t%Yt===vn){const e=(t+j)/Yt;return function(r,o){const i=r.pow(o,e);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%xe===be){const e=(t-be)/xe;return function(r,o){const i=r.mul(o,ht),f=r.pow(i,e),c=r.mul(o,f),s=r.mul(r.mul(c,ht),f),a=r.mul(c,r.sub(s,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return $n(t)}const Tn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Nn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Tn.reduce((r,o)=>(r[o]="function",r),e);return St(t,n)}function _n(t,e,n){if(n<K)throw new Error("Expected power > 0");if(n===K)return t.ONE;if(n===j)return e;let r=t.ONE,o=e;for(;n>K;)n&j&&(r=t.mul(r,o)),o=t.sqr(o),n>>=j;return r}function On(t,e){const n=new Array(e.length),r=e.reduce((i,f,c)=>t.is0(f)?i:(n[c]=i,t.mul(i,f)),t.ONE),o=t.inv(r);return e.reduceRight((i,f,c)=>t.is0(f)?i:(n[c]=t.mul(i,n[c]),t.mul(i,f)),o),n}function Oe(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Cn(t,e,n=!1,r={}){if(t<=K)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=Oe(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=Hn(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:se(o),ZERO:K,ONE:j,create:s=>P(s,t),isValid:s=>{if(typeof s!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof s}`);return K<=s&&s<t},is0:s=>s===K,isOdd:s=>(s&j)===j,neg:s=>P(-s,t),eql:(s,a)=>s===a,sqr:s=>P(s*s,t),add:(s,a)=>P(s+a,t),sub:(s,a)=>P(s-a,t),mul:(s,a)=>P(s*a,t),pow:(s,a)=>_n(c,s,a),div:(s,a)=>P(s*Dt(a,t),t),sqrN:s=>s*s,addN:(s,a)=>s+a,subN:(s,a)=>s-a,mulN:(s,a)=>s*a,inv:s=>Dt(s,t),sqrt:r.sqrt||(s=>f(c,s)),invertBatch:s=>On(c,s),cmov:(s,a,h)=>h?a:s,toBytes:s=>n?oe(s,i):ut(s,i),fromBytes:s=>{if(s.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${s.length}`);return n?re(s):M(s)}});return Object.freeze(c)}function Ce(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function qe(t){const e=Ce(t);return e+Math.ceil(e/2)}function qn(t,e,n=!1){const r=t.length,o=Ce(e),i=qe(e);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const f=n?M(t):re(t),c=P(f,e-j)+j;return n?oe(c,o):ut(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rn=BigInt(0),Vt=BigInt(1);function kn(t,e){const n=(o,i)=>{const f=i.negate();return o?f:i},r=o=>{const i=Math.ceil(e/o)+1,f=2**(o-1);return{windows:i,windowSize:f}};return{constTimeNegate:n,unsafeLadder(o,i){let f=t.ZERO,c=o;for(;i>Rn;)i&Vt&&(f=f.add(c)),c=c.double(),i>>=Vt;return f},precomputeWindow(o,i){const{windows:f,windowSize:c}=r(i),s=[];let a=o,h=a;for(let u=0;u<f;u++){h=a,s.push(h);for(let x=1;x<c;x++)h=h.add(a),s.push(h);a=h.double()}return s},wNAF(o,i,f){const{windows:c,windowSize:s}=r(o);let a=t.ZERO,h=t.BASE;const u=BigInt(2**o-1),x=2**o,b=BigInt(o);for(let p=0;p<c;p++){const l=p*s;let d=Number(f&u);f>>=b,d>s&&(d-=x,f+=Vt);const g=l,m=l+Math.abs(d)-1,S=p%2!==0,T=d<0;d===0?h=h.add(n(S,i[g])):a=a.add(n(T,i[m]))}return{p:a,f:h}},wNAFCached(o,i,f,c){const s=o._WINDOW_SIZE||1;let a=i.get(o);return a||(a=this.precomputeWindow(o,s),s!==1&&i.set(o,c(a))),this.wNAF(s,a,f)}}}function Re(t){return Nn(t.Fp),St(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Vn(t){const e=Re(t);St(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:jn,hexToBytes:Kn}=Un,dt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=dt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:jn(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=dt,n=typeof t=="string"?Kn(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=dt._parseInt(n.subarray(2)),{d:f,l:c}=dt._parseInt(i);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const h=a.toString(16);return h.length&1?`0${h}`:h},r=e(n(t.s)),o=e(n(t.r)),i=r.length/2,f=o.length/2,c=n(i),s=n(f);return`30${n(f+i+4)}02${s}${o}02${c}${r}`}},tt=BigInt(0),Y=BigInt(1);BigInt(2);const Ee=BigInt(3);BigInt(4);function Pn(t){const e=Vn(t),{Fp:n}=e,r=e.toBytes||((p,l,d)=>{const g=l.toAffine();return gt(Uint8Array.from([4]),n.toBytes(g.x),n.toBytes(g.y))}),o=e.fromBytes||(p=>{const l=p.subarray(1),d=n.fromBytes(l.subarray(0,n.BYTES)),g=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:d,y:g}});function i(p){const{a:l,b:d}=e,g=n.sqr(p),m=n.mul(g,p);return n.add(n.add(m,n.mul(p,l)),d)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function f(p){return typeof p=="bigint"&&tt<p&&p<e.n}function c(p){if(!f(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function s(p){const{allowedPrivateKeyLengths:l,nByteLength:d,wrapPrivateKey:g,n:m}=e;if(l&&typeof p!="bigint"){if(p instanceof Uint8Array&&(p=Et(p)),typeof p!="string"||!l.includes(p.length))throw new Error("Invalid key");p=p.padStart(d*2,"0")}let S;try{S=typeof p=="bigint"?p:M(Z("private key",p,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof p}`)}return g&&(S=P(S,m)),c(S),S}const a=new Map;function h(p){if(!(p instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,d,g){if(this.px=l,this.py=d,this.pz=g,l==null||!n.isValid(l))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(g==null||!n.isValid(g))throw new Error("z required")}static fromAffine(l){const{x:d,y:g}=l||{};if(!l||!n.isValid(d)||!n.isValid(g))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const m=S=>n.eql(S,n.ZERO);return m(d)&&m(g)?u.ZERO:new u(d,g,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const d=n.invertBatch(l.map(g=>g.pz));return l.map((g,m)=>g.toAffine(d[m])).map(u.fromAffine)}static fromHex(l){const d=u.fromAffine(o(Z("pointHex",l)));return d.assertValidity(),d}static fromPrivateKey(l){return u.BASE.multiply(s(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:d}=this.toAffine();if(!n.isValid(l)||!n.isValid(d))throw new Error("bad point: x or y not FE");const g=n.sqr(d),m=i(l);if(!n.eql(g,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:d,py:g,pz:m}=this,{px:S,py:T,pz:L}=l,E=n.eql(n.mul(d,L),n.mul(S,m)),B=n.eql(n.mul(g,L),n.mul(T,m));return E&&B}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:d}=e,g=n.mul(d,Ee),{px:m,py:S,pz:T}=this;let L=n.ZERO,E=n.ZERO,B=n.ZERO,A=n.mul(m,m),k=n.mul(S,S),H=n.mul(T,T),U=n.mul(m,S);return U=n.add(U,U),B=n.mul(m,T),B=n.add(B,B),L=n.mul(l,B),E=n.mul(g,H),E=n.add(L,E),L=n.sub(k,E),E=n.add(k,E),E=n.mul(L,E),L=n.mul(U,L),B=n.mul(g,B),H=n.mul(l,H),U=n.sub(A,H),U=n.mul(l,U),U=n.add(U,B),B=n.add(A,A),A=n.add(B,A),A=n.add(A,H),A=n.mul(A,U),E=n.add(E,A),H=n.mul(S,T),H=n.add(H,H),A=n.mul(H,U),L=n.sub(L,A),B=n.mul(H,k),B=n.add(B,B),B=n.add(B,B),new u(L,E,B)}add(l){h(l);const{px:d,py:g,pz:m}=this,{px:S,py:T,pz:L}=l;let E=n.ZERO,B=n.ZERO,A=n.ZERO;const k=e.a,H=n.mul(e.b,Ee);let U=n.mul(d,S),C=n.mul(g,T),q=n.mul(m,L),V=n.add(d,g),w=n.add(S,T);V=n.mul(V,w),w=n.add(U,C),V=n.sub(V,w),w=n.add(d,m);let y=n.add(S,L);return w=n.mul(w,y),y=n.add(U,q),w=n.sub(w,y),y=n.add(g,m),E=n.add(T,L),y=n.mul(y,E),E=n.add(C,q),y=n.sub(y,E),A=n.mul(k,w),E=n.mul(H,q),A=n.add(E,A),E=n.sub(C,A),A=n.add(C,A),B=n.mul(E,A),C=n.add(U,U),C=n.add(C,U),q=n.mul(k,q),w=n.mul(H,w),C=n.add(C,q),q=n.sub(U,q),q=n.mul(k,q),w=n.add(w,q),U=n.mul(C,w),B=n.add(B,U),U=n.mul(y,w),E=n.mul(V,E),E=n.sub(E,U),U=n.mul(V,C),A=n.mul(y,A),A=n.add(A,U),new u(E,B,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return b.wNAFCached(this,a,l,d=>{const g=n.invertBatch(d.map(m=>m.pz));return d.map((m,S)=>m.toAffine(g[S])).map(u.fromAffine)})}multiplyUnsafe(l){const d=u.ZERO;if(l===tt)return d;if(c(l),l===Y)return this;const{endo:g}=e;if(!g)return b.unsafeLadder(this,l);let{k1neg:m,k1:S,k2neg:T,k2:L}=g.splitScalar(l),E=d,B=d,A=this;for(;S>tt||L>tt;)S&Y&&(E=E.add(A)),L&Y&&(B=B.add(A)),A=A.double(),S>>=Y,L>>=Y;return m&&(E=E.negate()),T&&(B=B.negate()),B=new u(n.mul(B.px,g.beta),B.py,B.pz),E.add(B)}multiply(l){c(l);let d=l,g,m;const{endo:S}=e;if(S){const{k1neg:T,k1:L,k2neg:E,k2:B}=S.splitScalar(d);let{p:A,f:k}=this.wNAF(L),{p:H,f:U}=this.wNAF(B);A=b.constTimeNegate(T,A),H=b.constTimeNegate(E,H),H=new u(n.mul(H.px,S.beta),H.py,H.pz),g=A.add(H),m=k.add(U)}else{const{p:T,f:L}=this.wNAF(d);g=T,m=L}return u.normalizeZ([g,m])[0]}multiplyAndAddUnsafe(l,d,g){const m=u.BASE,S=(L,E)=>E===tt||E===Y||!L.equals(m)?L.multiplyUnsafe(E):L.multiply(E),T=S(this,d).add(S(l,g));return T.is0()?void 0:T}toAffine(l){const{px:d,py:g,pz:m}=this,S=this.is0();l==null&&(l=S?n.ONE:n.inv(m));const T=n.mul(d,l),L=n.mul(g,l),E=n.mul(m,l);if(S)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:T,y:L}}isTorsionFree(){const{h:l,isTorsionFree:d}=e;if(l===Y)return!0;if(d)return d(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:d}=e;return l===Y?this:d?d(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return Et(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const x=e.nBitLength,b=kn(u,e.endo?Math.ceil(x/2):x);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:s,weierstrassEquation:i,isWithinCurveOrder:f}}function Zn(t){const e=Re(t);return St(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function zn(t){const e=Zn(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function f(w){return tt<w&&w<n.ORDER}function c(w){return P(w,r)}function s(w){return Dt(w,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:x}=Pn({...e,toBytes(w,y,I){const $=y.toAffine(),v=n.toBytes($.x),N=gt;return I?N(Uint8Array.from([y.hasEvenY()?2:3]),v):N(Uint8Array.from([4]),v,n.toBytes($.y))},fromBytes(w){const y=w.length,I=w[0],$=w.subarray(1);if(y===o&&(I===2||I===3)){const v=M($);if(!f(v))throw new Error("Point is not on curve");const N=u(v);let R=n.sqrt(N);const O=(R&Y)===Y;return(I&1)===1!==O&&(R=n.neg(R)),{x:v,y:R}}else if(y===i&&I===4){const v=n.fromBytes($.subarray(0,n.BYTES)),N=n.fromBytes($.subarray(n.BYTES,2*n.BYTES));return{x:v,y:N}}else throw new Error(`Point of length ${y} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),b=w=>Et(ut(w,e.nByteLength));function p(w){const y=r>>Y;return w>y}function l(w){return p(w)?c(-w):w}const d=(w,y,I)=>M(w.slice(y,I));class g{constructor(y,I,$){this.r=y,this.s=I,this.recovery=$,this.assertValidity()}static fromCompact(y){const I=e.nByteLength;return y=Z("compactSignature",y,I*2),new g(d(y,0,I),d(y,I,2*I))}static fromDER(y){const{r:I,s:$}=dt.toSig(Z("DER",y));return new g(I,$)}assertValidity(){if(!x(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!x(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new g(this.r,this.s,y)}recoverPublicKey(y){const{r:I,s:$,recovery:v}=this,N=B(Z("msgHash",y));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const R=v===2||v===3?I+e.n:I;if(R>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=v&1?"03":"02",D=a.fromHex(O+b(R)),nt=s(R),wt=c(-N*nt),Bt=c($*nt),rt=a.BASE.multiplyAndAddUnsafe(D,wt,Bt);if(!rt)throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return mt(this.toDERHex())}toDERHex(){return dt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return mt(this.toCompactHex())}toCompactHex(){return b(this.r)+b(this.s)}}const m={isValidPrivateKey(w){try{return h(w),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const w=qe(e.n);return qn(e.randomBytes(w),e.n)},precompute(w=8,y=a.BASE){return y._setWindowSize(w),y.multiply(BigInt(3)),y}};function S(w,y=!0){return a.fromPrivateKey(w).toRawBytes(y)}function T(w){const y=w instanceof Uint8Array,I=typeof w=="string",$=(y||I)&&w.length;return y?$===o||$===i:I?$===2*o||$===2*i:w instanceof a}function L(w,y,I=!0){if(T(w))throw new Error("first arg must be private key");if(!T(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(h(w)).toRawBytes(I)}const E=e.bits2int||function(w){const y=M(w),I=w.length*8-e.nBitLength;return I>0?y>>BigInt(I):y},B=e.bits2int_modN||function(w){return c(E(w))},A=se(e.nBitLength);function k(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(tt<=w&&w<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return ut(w,e.nByteLength)}function H(w,y,I=U){if(["recovered","canonical"].some(lt=>lt in I))throw new Error("sign() legacy options not supported");const{hash:$,randomBytes:v}=e;let{lowS:N,prehash:R,extraEntropy:O}=I;N==null&&(N=!0),w=Z("msgHash",w),R&&(w=Z("prehashed msgHash",$(w)));const D=B(w),nt=h(y),wt=[k(nt),k(D)];if(O!=null){const lt=O===!0?v(n.BYTES):O;wt.push(Z("extraEntropy",lt))}const Bt=gt(...wt),rt=D;function Ct(lt){const pt=E(lt);if(!x(pt))return;const de=s(pt),yt=a.BASE.multiply(pt).toAffine(),F=c(yt.x);if(F===tt)return;const bt=c(de*c(rt+F*nt));if(bt===tt)return;let ge=(yt.x===F?0:2)|Number(yt.y&Y),we=bt;return N&&p(bt)&&(we=l(bt),ge^=1),new g(F,we,ge)}return{seed:Bt,k2sig:Ct}}const U={lowS:e.lowS,prehash:!1},C={lowS:e.lowS,prehash:!1};function q(w,y,I=U){const{seed:$,k2sig:v}=H(w,y,I),N=e;return _e(N.hash.outputLen,N.nByteLength,N.hmac)($,v)}a.BASE._setWindowSize(8);function V(w,y,I,$=C){var yt;const v=w;if(y=Z("msgHash",y),I=Z("publicKey",I),"strict"in $)throw new Error("options.strict was renamed to lowS");const{lowS:N,prehash:R}=$;let O,D;try{if(typeof v=="string"||v instanceof Uint8Array)try{O=g.fromDER(v)}catch(F){if(!(F instanceof dt.Err))throw F;O=g.fromCompact(v)}else if(typeof v=="object"&&typeof v.r=="bigint"&&typeof v.s=="bigint"){const{r:F,s:bt}=v;O=new g(F,bt)}else throw new Error("PARSE");D=a.fromHex(I)}catch(F){if(F.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&O.hasHighS())return!1;R&&(y=e.hash(y));const{r:nt,s:wt}=O,Bt=B(y),rt=s(wt),Ct=c(Bt*rt),lt=c(nt*rt),pt=(yt=a.BASE.multiplyAndAddUnsafe(D,Ct,lt))==null?void 0:yt.toAffine();return pt?c(pt.x)===nt:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:L,sign:q,verify:V,ProjectivePoint:a,Signature:g,utils:m}}let ke=class extends $e{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,on(e);const r=ee(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<i.length;f++)i[f]^=54;this.iHash.update(i),this.oHash=e.create();for(let f=0;f<i.length;f++)i[f]^=106;this.oHash.update(i),i.fill(0)}update(e){return vt(this),this.iHash.update(e),this}digestInto(e){vt(this),ve(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:i,blockLen:f,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=f,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const Ve=(t,e,n)=>new ke(t,e).update(n).digest();Ve.create=(t,e)=>new ke(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Mn(t){return{hash:t,hmac:(e,...n)=>Ve(t,e,an(...n)),randomBytes:He}}function Gn(t,e){const n=r=>zn({...t,...Mn(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _t=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Lt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),je=BigInt(1),$t=BigInt(2),me=(t,e)=>(t+e/$t)/e;function Ke(t){const e=_t,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),f=BigInt(23),c=BigInt(44),s=BigInt(88),a=t*t*t%e,h=a*a*t%e,u=G(h,n,e)*h%e,x=G(u,n,e)*h%e,b=G(x,$t,e)*a%e,p=G(b,o,e)*b%e,l=G(p,i,e)*p%e,d=G(l,c,e)*l%e,g=G(d,s,e)*d%e,m=G(g,c,e)*l%e,S=G(m,n,e)*h%e,T=G(S,f,e)*p%e,L=G(T,r,e)*a%e,E=G(L,$t,e);if(!Ft.eql(Ft.sqr(E),t))throw new Error("Cannot find square root");return E}const Ft=Cn(_t,void 0,void 0,{sqrt:Ke}),ie=Gn({a:BigInt(0),b:BigInt(7),Fp:Ft,n:Lt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Lt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-je*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,f=BigInt("0x100000000000000000000000000000000"),c=me(i*t,e),s=me(-r*t,e);let a=P(t-c*n-s*o,e),h=P(-c*r-s*i,e);const u=a>f,x=h>f;if(u&&(a=e-a),x&&(h=e-h),a>f||h>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:x,k2:h}}}},Gt),Ot=BigInt(0),Pe=t=>typeof t=="bigint"&&Ot<t&&t<_t,Yn=t=>typeof t=="bigint"&&Ot<t&&t<Lt,Be={};function Ht(t,...e){let n=Be[t];if(n===void 0){const r=Gt(Uint8Array.from(t,o=>o.charCodeAt(0)));n=gt(r,r),Be[t]=n}return Gt(gt(n,...e))}const ce=t=>t.toRawBytes(!0).slice(1),Wt=t=>ut(t,32),jt=t=>P(t,_t),At=t=>P(t,Lt),fe=ie.ProjectivePoint,Dn=(t,e,n)=>fe.BASE.multiplyAndAddUnsafe(t,e,n);function Xt(t){let e=ie.utils.normPrivateKeyToScalar(t),n=fe.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:At(-e),bytes:ce(n)}}function Ze(t){if(!Pe(t))throw new Error("bad x: need 0 < x < p");const e=jt(t*t),n=jt(e*t+BigInt(7));let r=Ke(n);r%$t!==Ot&&(r=jt(-r));const o=new fe(t,r,je);return o.assertValidity(),o}function ze(...t){return At(M(Ht("BIP0340/challenge",...t)))}function Fn(t){return Xt(t).bytes}function Wn(t,e,n=He(32)){const r=Z("message",t),{bytes:o,scalar:i}=Xt(e),f=Z("auxRand",n,32),c=Wt(i^M(Ht("BIP0340/aux",f))),s=Ht("BIP0340/nonce",c,o,r),a=At(M(s));if(a===Ot)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=Xt(a),x=ze(h,o,r),b=new Uint8Array(64);if(b.set(h,0),b.set(Wt(At(u+x*i)),32),!Me(b,r,o))throw new Error("sign: Invalid signature produced");return b}function Me(t,e,n){const r=Z("signature",t,64),o=Z("message",e),i=Z("publicKey",n,32);try{const f=Ze(M(i)),c=M(r.subarray(0,32));if(!Pe(c))return!1;const s=M(r.subarray(32,64));if(!Yn(s))return!1;const a=ze(Wt(c),ce(f),o),h=Dn(f,s,At(-a));return!(!h||!h.hasEvenY()||h.toAffine().x!==c)}catch{return!1}}const qr={getPublicKey:Fn,sign:Wn,verify:Me,utils:{randomPrivateKey:ie.utils.randomPrivateKey,lift_x:Ze,pointToBytes:ce,numberToBytesBE:ut,bytesToNumberBE:M,taggedHash:Ht,mod:P}},Kt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ae=t=>t instanceof Uint8Array,Pt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),X=(t,e)=>t<<32-e|t>>>e,Xn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Xn)throw new Error("Non little-endian hardware is not supported");const Qn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Rr(t){if(!ae(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Qn[t[n]];return e}function kr(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=r*2,i=t.slice(o,o+2),f=Number.parseInt(i,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");n[r]=f}return n}function Jn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function It(t){if(typeof t=="string"&&(t=Jn(t)),!ae(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Vr(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!ae(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class Ge{clone(){return this._cloneInto()}}function Ye(t){const e=r=>t().update(It(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function jr(t=32){if(Kt&&typeof Kt.getRandomValues=="function")return Kt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Qt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function tr(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function De(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function er(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Qt(t.outputLen),Qt(t.blockLen)}function nr(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function rr(t,e){De(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Q={number:Qt,bool:tr,bytes:De,hash:er,exists:nr,output:rr};function or(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),f=Number(n>>o&i),c=Number(n&i),s=r?4:0,a=r?0:4;t.setUint32(e+s,f,r),t.setUint32(e+a,c,r)}class sr extends Ge{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pt(this.buffer)}update(e){Q.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=It(e);const i=e.length;for(let f=0;f<i;){const c=Math.min(o-this.pos,i-f);if(c===o){const s=Pt(e);for(;o<=i-f;f+=o)this.process(s,f);continue}r.set(e.subarray(f,f+c),this.pos),this.pos+=c,f+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Q.exists(this),Q.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;or(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=Pt(e),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=s/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)c.setUint32(4*u,h[u],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:f,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=f,o%n&&e.buffer.set(r),e}}const ir=(t,e,n)=>t&e^~t&n,cr=(t,e,n)=>t&e^t&n^e&n,fr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),it=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ct=new Uint32Array(64);class Fe extends sr{constructor(){super(64,32,8,!1),this.A=it[0]|0,this.B=it[1]|0,this.C=it[2]|0,this.D=it[3]|0,this.E=it[4]|0,this.F=it[5]|0,this.G=it[6]|0,this.H=it[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:f,G:c,H:s}=this;return[e,n,r,o,i,f,c,s]}set(e,n,r,o,i,f,c,s){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=f|0,this.G=c|0,this.H=s|0}process(e,n){for(let u=0;u<16;u++,n+=4)ct[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const x=ct[u-15],b=ct[u-2],p=X(x,7)^X(x,18)^x>>>3,l=X(b,17)^X(b,19)^b>>>10;ct[u]=l+ct[u-7]+p+ct[u-16]|0}let{A:r,B:o,C:i,D:f,E:c,F:s,G:a,H:h}=this;for(let u=0;u<64;u++){const x=X(c,6)^X(c,11)^X(c,25),b=h+x+ir(c,s,a)+fr[u]+ct[u]|0,l=(X(r,2)^X(r,13)^X(r,22))+cr(r,o,i)|0;h=a,a=s,s=c,c=f+b|0,f=i,i=o,o=r,r=b+l|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,f=f+this.D|0,c=c+this.E|0,s=s+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(r,o,i,f,c,s,a,h)}roundClean(){ct.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class ar extends Fe{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Kr=Ye(()=>new Fe);Ye(()=>new ar);function Zt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function Ae(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function ur(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function et(t,...e){if(!ur(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const z=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),lr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!lr)throw new Error("Non little-endian hardware is not supported");function hr(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function Pr(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const dr=(t,e)=>(Object.assign(e,t),e),at=16,gr=283;function ue(t){return t<<1^gr&-(t>>7)}function xt(t,e){let n=0;for(;e>0;e>>=1)n^=t&-(e&1),t=ue(t);return n}const Jt=(()=>{let t=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=ue(r))t[n]=r;const e=new Uint8Array(256);e[0]=99;for(let n=0;n<255;n++){let r=t[255-n];r|=r<<8,e[t[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return e})(),wr=Jt.map((t,e)=>Jt.indexOf(e)),pr=t=>t<<24|t>>>8,zt=t=>t<<8|t>>>24;function We(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((a,h)=>e(t[h])),r=n.map(zt),o=r.map(zt),i=o.map(zt),f=new Uint32Array(256*256),c=new Uint32Array(256*256),s=new Uint16Array(256*256);for(let a=0;a<256;a++)for(let h=0;h<256;h++){const u=a*256+h;f[u]=n[a]^r[h],c[u]=o[a]^i[h],s[u]=t[a]<<8|t[h]}return{sbox:t,sbox2:s,T0:n,T1:r,T2:o,T3:i,T01:f,T23:c}}const le=We(Jt,t=>xt(t,3)<<24|t<<16|t<<8|xt(t,2)),Xe=We(wr,t=>xt(t,11)<<24|xt(t,13)<<16|xt(t,9)<<8|xt(t,14)),yr=(()=>{const t=new Uint8Array(16);for(let e=0,n=1;e<16;e++,n=ue(n))t[e]=n;return t})();function Qe(t){et(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:n}=le,r=z(t),o=r.length,i=c=>J(n,c,c,c,c),f=new Uint32Array(e+28);f.set(r);for(let c=o;c<f.length;c++){let s=f[c-1];c%o===0?s=i(pr(s))^yr[c/o-1]:o>6&&c%o===4&&(s=i(s)),f[c]=f[c-o]^s}return f}function br(t){const e=Qe(t),n=e.slice(),r=e.length,{sbox2:o}=le,{T0:i,T1:f,T2:c,T3:s}=Xe;for(let a=0;a<r;a+=4)for(let h=0;h<4;h++)n[a+h]=e[r-a-4+h];e.fill(0);for(let a=4;a<r-4;a++){const h=n[a],u=J(o,h,h,h,h);n[a]=i[u&255]^f[u>>>8&255]^c[u>>>16&255]^s[u>>>24]}return n}function ft(t,e,n,r,o,i){return t[n<<8&65280|r>>>8&255]^e[o>>>8&65280|i>>>24&255]}function J(t,e,n,r,o){return t[e&255|n&65280]|t[r>>>16&255|o>>>16&65280]<<16}function Ie(t,e,n,r,o){const{sbox2:i,T01:f,T23:c}=le;let s=0;e^=t[s++],n^=t[s++],r^=t[s++],o^=t[s++];const a=t.length/4-2;for(let p=0;p<a;p++){const l=t[s++]^ft(f,c,e,n,r,o),d=t[s++]^ft(f,c,n,r,o,e),g=t[s++]^ft(f,c,r,o,e,n),m=t[s++]^ft(f,c,o,e,n,r);e=l,n=d,r=g,o=m}const h=t[s++]^J(i,e,n,r,o),u=t[s++]^J(i,n,r,o,e),x=t[s++]^J(i,r,o,e,n),b=t[s++]^J(i,o,e,n,r);return{s0:h,s1:u,s2:x,s3:b}}function xr(t,e,n,r,o){const{sbox2:i,T01:f,T23:c}=Xe;let s=0;e^=t[s++],n^=t[s++],r^=t[s++],o^=t[s++];const a=t.length/4-2;for(let p=0;p<a;p++){const l=t[s++]^ft(f,c,e,o,r,n),d=t[s++]^ft(f,c,n,e,o,r),g=t[s++]^ft(f,c,r,n,e,o),m=t[s++]^ft(f,c,o,r,n,e);e=l,n=d,r=g,o=m}const h=t[s++]^J(i,e,o,r,n),u=t[s++]^J(i,n,e,o,r),x=t[s++]^J(i,r,n,e,o),b=t[s++]^J(i,o,r,n,e);return{s0:h,s1:u,s2:x,s3:b}}function Je(t,e){if(!e)return new Uint8Array(t);if(et(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function Er(t){if(et(t),t.length%at!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${at}`)}function mr(t,e,n){let r=t.length;const o=r%at;if(!e&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const i=z(t);if(e){let s=at-o;s||(s=at),r=r+s}const f=Je(r,n),c=z(f);return{b:i,o:c,out:f}}function Br(t,e){if(!e)return t;const n=t.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=t[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=t.subarray(0,-r);for(let i=0;i<r;i++)if(t[n-i-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function Ar(t){const e=new Uint8Array(16),n=z(e);e.set(t);const r=at-t.length;for(let o=at-r;o<at;o++)e[o]=r;return n}const Zr=dr({blockSize:16,nonceLength:16},function(e,n,r={}){et(e),et(n,16);const o=!r.disablePadding;return{encrypt:(i,f)=>{const c=Qe(e),{b:s,o:a,out:h}=mr(i,o,f),u=z(n);let x=u[0],b=u[1],p=u[2],l=u[3],d=0;for(;d+4<=s.length;)x^=s[d+0],b^=s[d+1],p^=s[d+2],l^=s[d+3],{s0:x,s1:b,s2:p,s3:l}=Ie(c,x,b,p,l),a[d++]=x,a[d++]=b,a[d++]=p,a[d++]=l;if(o){const g=Ar(i.subarray(d*4));x^=g[0],b^=g[1],p^=g[2],l^=g[3],{s0:x,s1:b,s2:p,s3:l}=Ie(c,x,b,p,l),a[d++]=x,a[d++]=b,a[d++]=p,a[d++]=l}return c.fill(0),h},decrypt:(i,f)=>{Er(i);const c=br(e),s=z(n),a=Je(i.length,f),h=z(i),u=z(a);let x=s[0],b=s[1],p=s[2],l=s[3];for(let d=0;d+4<=h.length;){const g=x,m=b,S=p,T=l;x=h[d+0],b=h[d+1],p=h[d+2],l=h[d+3];const{s0:L,s1:E,s2:B,s3:A}=xr(c,x,b,p,l);u[d++]=L^g,u[d++]=E^m,u[d++]=B^S,u[d++]=A^T}return c.fill(0),Br(a,o)}}}),tn=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),Ir=tn("expand 16-byte k"),Sr=tn("expand 32-byte k"),Ur=z(Ir),en=z(Sr);en.slice();function _(t,e){return t<<e|t>>>32-e}function te(t){return t.byteOffset%4===0}const Ut=64,vr=16,nn=2**32-1,Se=new Uint32Array;function Lr(t,e,n,r,o,i,f,c){const s=o.length,a=new Uint8Array(Ut),h=z(a),u=te(o)&&te(i),x=u?z(o):Se,b=u?z(i):Se;for(let p=0;p<s;f++){if(t(e,n,r,h,f,c),f>=nn)throw new Error("arx: counter overflow");const l=Math.min(Ut,s-p);if(u&&l===Ut){const d=p/4;if(p%4!==0)throw new Error("arx: invalid block position");for(let g=0,m;g<vr;g++)m=d+g,b[m]=x[m]^h[g];p+=Ut;continue}for(let d=0,g;d<l;d++)g=p+d,i[g]=o[g]^a[d];p+=l}}function $r(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:i,rounds:f}=hr({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return Zt(o),Zt(f),Ae(i),Ae(n),(c,s,a,h,u=0)=>{et(c),et(s),et(a);const x=a.length;if(h||(h=new Uint8Array(x)),et(h),Zt(u),u<0||u>=nn)throw new Error("arx: counter overflow");if(h.length<x)throw new Error(`arx: output (${h.length}) is shorter than data (${x})`);const b=[];let p=c.length,l,d;if(p===32)l=c.slice(),b.push(l),d=en;else if(p===16&&n)l=new Uint8Array(32),l.set(c),l.set(c,16),d=Ur,b.push(l);else throw new Error(`arx: invalid 32-byte key, got length=${p}`);te(s)||(s=s.slice(),b.push(s));const g=z(l);if(r){if(s.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,g,z(s.subarray(0,16)),g),s=s.subarray(16)}const m=16-o;if(m!==s.length)throw new Error(`arx: nonce must be ${m} or 16 bytes`);if(m!==12){const T=new Uint8Array(12);T.set(s,i?0:12-s.length),s=T,b.push(s)}const S=z(s);for(Lr(t,d,g,S,a,h,u,f);b.length>0;)b.pop().fill(0);return h}}function Hr(t,e,n,r,o,i=20){let f=t[0],c=t[1],s=t[2],a=t[3],h=e[0],u=e[1],x=e[2],b=e[3],p=e[4],l=e[5],d=e[6],g=e[7],m=o,S=n[0],T=n[1],L=n[2],E=f,B=c,A=s,k=a,H=h,U=u,C=x,q=b,V=p,w=l,y=d,I=g,$=m,v=S,N=T,R=L;for(let D=0;D<i;D+=2)E=E+H|0,$=_($^E,16),V=V+$|0,H=_(H^V,12),E=E+H|0,$=_($^E,8),V=V+$|0,H=_(H^V,7),B=B+U|0,v=_(v^B,16),w=w+v|0,U=_(U^w,12),B=B+U|0,v=_(v^B,8),w=w+v|0,U=_(U^w,7),A=A+C|0,N=_(N^A,16),y=y+N|0,C=_(C^y,12),A=A+C|0,N=_(N^A,8),y=y+N|0,C=_(C^y,7),k=k+q|0,R=_(R^k,16),I=I+R|0,q=_(q^I,12),k=k+q|0,R=_(R^k,8),I=I+R|0,q=_(q^I,7),E=E+U|0,R=_(R^E,16),y=y+R|0,U=_(U^y,12),E=E+U|0,R=_(R^E,8),y=y+R|0,U=_(U^y,7),B=B+C|0,$=_($^B,16),I=I+$|0,C=_(C^I,12),B=B+C|0,$=_($^B,8),I=I+$|0,C=_(C^I,7),A=A+q|0,v=_(v^A,16),V=V+v|0,q=_(q^V,12),A=A+q|0,v=_(v^A,8),V=V+v|0,q=_(q^V,7),k=k+H|0,N=_(N^k,16),w=w+N|0,H=_(H^w,12),k=k+H|0,N=_(N^k,8),w=w+N|0,H=_(H^w,7);let O=0;r[O++]=f+E|0,r[O++]=c+B|0,r[O++]=s+A|0,r[O++]=a+k|0,r[O++]=h+H|0,r[O++]=u+U|0,r[O++]=x+C|0,r[O++]=b+q|0,r[O++]=p+V|0,r[O++]=l+w|0,r[O++]=d+y|0,r[O++]=g+I|0,r[O++]=m+$|0,r[O++]=S+v|0,r[O++]=T+N|0,r[O++]=L+R|0}const zr=$r(Hr,{counterRight:!1,counterLength:4,allowShortKeys:!1});class rn extends Ge{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Q.hash(e);const r=It(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<i.length;f++)i[f]^=54;this.iHash.update(i),this.oHash=e.create();for(let f=0;f<i.length;f++)i[f]^=106;this.oHash.update(i),i.fill(0)}update(e){return Q.exists(this),this.iHash.update(e),this}digestInto(e){Q.exists(this),Q.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:i,blockLen:f,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=f,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const he=(t,e,n)=>new rn(t,e).update(n).digest();he.create=(t,e)=>new rn(t,e);function Mr(t,e,n){return Q.hash(t),he(t,It(n),It(e))}const Mt=new Uint8Array([0]),Ue=new Uint8Array;function Gr(t,e,n,r=32){if(Q.hash(t),Q.number(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/t.outputLen);n===void 0&&(n=Ue);const i=new Uint8Array(o*t.outputLen),f=he.create(t,e),c=f._cloneInto(),s=new Uint8Array(f.outputLen);for(let a=0;a<o;a++)Mt[0]=a+1,c.update(a===0?Ue:s).update(n).update(Mt).digestInto(s),i.set(s,t.outputLen*a),f._cloneInto(c);return f.destroy(),c.destroy(),s.fill(0),Mt.fill(0),i.slice(0,r)}export{Zr as a,Rr as b,Vr as c,zr as d,Mr as e,Pr as f,Kr as g,kr as h,qr as i,Gr as j,he as k,jr as r,ie as s};
